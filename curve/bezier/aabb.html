<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body {
      margin: 0;
        background-color: ivory;
    }
    #canvas {
        border:1px solid green;
    }
  </style>
  <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/jqueryui/1.13.2/jquery-ui.js"></script>
</head>
<body>
  
  <canvas id="canvas" width=400 height=300></canvas>
  <br/>Num point:
  <input id="nPts" name="sang" value="5" size="5" />
  <br/>
  <input id="goBut" type="button" value="Go" />Area:
  <input id="area" name="sang" value="5" size="5" />
  <script>
    // 参考资料
    // https://floris.briolas.nl/floris/2009/10/bounding-box-of-cubic-bezier/
    // https://stackoverflow.com/questions/24809978/calculating-the-bounding-box-of-cubic-bezier-curve
    // https://pomax.github.io/bezierinfo/#boundingbox
    
    // canvas and mousedown related variables
    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");
    var $canvas = $("#canvas");
    var canvasOffset = $canvas.offset();
    var offsetX = canvasOffset.left;
    var offsetY = canvasOffset.top;
    var scrollX = $canvas.scrollLeft();
    var scrollY = $canvas.scrollTop();

    // save canvas size to vars b/ they're used often
    var canvasWidth = canvas.width;
    var canvasHeight = canvas.height;
    function calculateTangentVector(P) {

      const x0 = P[0].X;
      const x1 = P[1].X;
      const x2 = P[2].X;
      const x3 = P[3].X;
      const y0 = P[0].Y;
      const y1 = P[1].Y;
      const y2 = P[2].Y;
      const y3 = P[3].Y;

      const A = x3 - 3 * x2 + 3 * x1 - x0;
      const B = 3 * x2 - 6 * x1 + 3 * x0;
      const C = 3 * x1 - 3 * x0;
      const D = x0;

      const E = y3 - 3 * y2 + 3 * y1 - y0;
      const F = 3 * y2 - 6 * y1 + 3 * y0;
      const G = 3 * y1 - 3 * y0;
      const H = y0;
      for (let t = 0; t <= 1; t += 0.5)  
      {
        const vx = 3 * A * Math.pow(t, 2) + 2 * B * t + C;
        const vy = 3 * E * Math.pow(t, 2) + 2 * F * t + G;
        // console.log(vx, vy)
        ctx.fillStyle = 'red';
        ctx.rect(vx, vy, 1, 10);
        ctx.fill();
      }

      

      // return { x: vx, y: vy };
    }

    function getCoefficents(P){
      calculateTangentVector(P)
      // const x0 = P[0].X;
      // const x1 = P[1].X;
      // const x2 = P[2].X;
      // const x3 = P[3].X;
      // const y0 = P[0].Y;
      // const y1 = P[1].Y;
      // const y2 = P[2].Y;
      // const y3 = P[3].Y;

      // const A = x3 - 3 * x2 + 3 * x1 - x0
      // const B = 3 * x2 - 6 * x1 + 3 * x0
      // const C = 3 * x1 - 3 * x0
      // const D = x0

      // const E = y3 - 3 * y2 + 3 * y1 - y0
      // const F = 3 * y2 - 6 * y1 + 3 * y0
      // const G = 3 * y1 - 3 * y0
      // const H = y0;

      // for (let t = 0; t <= 1; t += 0.05)  
      // {
      //   const x = A * Math.pow(t, 3) + B * Math.pow(t, 2) + C * t + D 
      //   const y = E * Math.pow(t, 3) + F * Math.pow(t, 2) + G * t + H 
      //   const vx = 3 * A * Math.pow(t, 2) + 2 * B * t + C 
      //   const vy = 3 * E * Math.pow(t, 2) + 2 * F * t + G 
      //   // console.log(vx, vy)
      //   ctx.fillStyle = 'red';
      //   ctx.rect(x, y, 1, 10);
      //   ctx.fill();
      // }

      // var a = 3 * P[3].X - 9 * P[2].X + 9 * P[1].X - 3 * P[0].X;
      // var b = 6 * P[0].X - 12 * P[1].X + 6 * P[2].X;
      // var c = 3 * P[1].X - 3 * P[0].X;

      // var d = 3 * P[3].Y - 9 * P[2].Y + 9 * P[1].Y - 3 * P[0].Y;
      // var e = 6 * P[0].Y - 12 * P[1].Y + 6 * P[2].Y;
      // var f = 3 * P[1].Y - 3 * P[0].Y;
      
      // for (let t = 0; t <= 1; t += 0.05)  
      // {
      //   // const a t^2 + b t + c
      //   const x = a * t * t + b * t + c
      //   const y = d * t * t + e * t + f
        
      //   ctx.fillStyle = 'red';
      //   ctx.rect(x, y, 1, 10);
      //   ctx.fill();
      // }
      

      
      // return [A,B,C,D,E,F,G,H];
    }

    // The control points
    // The control points
    //var P = [{X:  13, Y: 224 }, 
    //         {X: 150, Y: 100 }, 
    //         {X: 251, Y:  93 }, 
    //         {X: 341, Y: 224 }, ];

    // 绘制正常贝塞尔曲线
    // 四个点：起点，控制点1，控制点2，终点
    var P = [{X: 120, Y: 160 }, 
            {X:  35, Y: 200 }, 
            {X: 220, Y: 260 }, 
            {X: 180, Y:  40 }, ];
        

    ctx.lineWidth = 6;
    ctx.strokeStyle = "#333";
    ctx.beginPath();
    ctx.moveTo(P[0].X, P[0].Y);
    ctx.bezierCurveTo(P[1].X, P[1].Y, P[2].X, P[2].Y, P[3].X, P[3].Y);
    ctx.stroke();

    // 绘制控制点拆线
    // draw the control polygon
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(P[0].X, P[0].Y);
    ctx.lineTo(P[1].X, P[1].Y);
    ctx.lineTo(P[2].X, P[2].Y);
    ctx.lineTo(P[3].X, P[3].Y);
    ctx.stroke();

    // 根据传入的 poly 四个控制点，和 t 值计算出具体的坐标值
    function evalBez(poly, t) {
        // 起点，控制点1，控制点2，终点 计算出 x 坐标
        // x = A (1-t)^3 +3 B t (1-t)^2 + 3 C t^2 (1-t) + D t^3
        var x = poly[0] * (1 - t) * (1 - t) * (1 - t) + 3 * poly[1] * t * (1 - t) * (1 - t) + 3 * poly[2] * t * t * (1 - t) + poly[3] * t * t * t;
        return x;
    }

    // 四个点的 x
    var PX = [P[0].X, P[1].X, P[2].X, P[3].X];
    // 四个点的 y
    var PY = [P[0].Y, P[1].Y, P[2].Y, P[3].Y];

    /**
     * 模拟曲线绘制控制
     * n 用于控制曲线线断精度
    */
    function findarea(n) {
        ctx.lineWidth = 3;
        ctx.strokeStyle = "#f00";
        ctx.beginPath();

        var nSteps = n - 1;
        var x = [P[0].X];
        var y = [P[0].Y];
        ctx.moveTo(x[0], y[0]);

        var area = 0.0;
        for (var i = 1; i <= nSteps; ++i) {
            var t = i / nSteps;
            x[i] = evalBez(PX, t);
            y[i] = evalBez(PY, t);
            // ctx.lineTo(x[i], y[i]);
            area += (x[i] - x[i - 1]) * (y[i - 1] + y[i]) / 2;
            if (x[i] < x[i - 1]) console.log("Not strictly increasing in x, area will be incorrect");
        }
        ctx.stroke();
        $("#area").val(area);
        getCoefficents(P);
    }

    // 找出曲线的 BB(bounding box)
    function findBB() {
      /**
        x 指代的是一维的坐标公式，二维的就是 x,y 算 2 遍
        
        坐标方程： x = A (1-t)^3 +3 B t (1-t)^2 + 3 C t^2 (1-t) + D t^3

        对其求导，关于 t 的微分，得到微分方程
        
        dx/dt =  3 (B - A) (1-t)^2 + 6 (C - B) (1-t) t + 3 (D - C) t^2
              =  [3 (D - C) - 6 (C - B) + 3 (B - A)] t^2
              + [ -6 (B - A) - 6 (C - B)] t
              + 3 (B - A) 
              =  (3 D - 9 C + 9 B - 3 A) t^2 + (6 A - 12 B + 6 C) t + 3 (B - A)
        
        合并整理后是一个二次函数： 

        dx/dt = a t^2 + b t + c
        
        我们要解决的是
        
        dx/dt = 0

        a t^2 + b t + c = 0
      **/
      
        var a = 3 * P[3].X - 9 * P[2].X + 9 * P[1].X - 3 * P[0].X;
        var b = 6 * P[0].X - 12 * P[1].X + 6 * P[2].X;
        var c = 3 * P[1].X - 3 * P[0].X;

        /**
          
          可用求根公式
          - b +/- sqrt(b^2-4 a c)
          -----------------------
                  2 a
          解方程可得 两个解（根） t0,t1, 无解，或 1 个解

          我们只关心 0 <= t <= 1 的情况

          这就有了四个点的极值，起点，终点，和两个解
        */
        
        // 先处理 X 轴
         
        // delta 判断 b^2-4ac
        var disc = b * b - 4 * a * c;
        // xl：x 最小值
        // xh：x 最大值
        var xl = P[0].X;
        var xh = P[0].X;
        if (P[3].X < xl) xl = P[3].X;
        if (P[3].X > xh) xh = P[3].X;
        // delta  大于等于 0 即为有解
        // 找到局部极限值 local extreme
        // 需要判断处理 2 个根
        if (disc >= 0) {
            var t1 = (-b + Math.sqrt(disc)) / (2 * a);
            console.log("t1 " + t1);
            // 用 t1 值 代入算出具体的 x 值即真坐标值
            if (t1 > 0 && t1 < 1) {
                var x1 = evalBez(PX, t1);
                if (x1 < xl) xl = x1;
                if (x1 > xh) xh = x1;
            }

            var t2 = (-b - Math.sqrt(disc)) / (2 * a);
            console.log("t2 " + t2);
            if (t2 > 0 && t2 < 1) {
                var x2 = evalBez(PX, t2);
                if (x2 < xl) xl = x2;
                if (x2 > xh) xh = x2;
            }
        }
        // Y 轴进行相同的操作
        a = 3 * P[3].Y - 9 * P[2].Y + 9 * P[1].Y - 3 * P[0].Y;
        b = 6 * P[0].Y - 12 * P[1].Y + 6 * P[2].Y;
        c = 3 * P[1].Y - 3 * P[0].Y;
        disc = b * b - 4 * a * c;
        // yl: y 最小值
        // yh: y 最大值
        var yl = P[0].Y;
        var yh = P[0].Y;
        if (P[3].Y < yl) yl = P[3].Y;
        if (P[3].Y > yh) yh = P[3].Y;
        if (disc >= 0) {
            var t1 = (-b + Math.sqrt(disc)) / (2 * a);
            console.log("t3 " + t1);

            if (t1 > 0 && t1 < 1) {
                var y1 = evalBez(PY, t1);
                if (y1 < yl) yl = y1;
                if (y1 > yh) yh = y1;
            }

            var t2 = (-b - Math.sqrt(disc)) / (2 * a);
            console.log("t4 " + t2);

            if (t2 > 0 && t2 < 1) {
                var y2 = evalBez(PY, t2);
                if (y2 < yl) yl = y2;
                if (y2 > yh) yh = y2;
            }
        }
        // 画出 BB
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(xl, yl); // 起点，左
        ctx.lineTo(xl, yh); // 上
        ctx.lineTo(xh, yh); // 右上
        ctx.lineTo(xh, yl); // 右下
        ctx.lineTo(xl, yl); // 终点，左
        ctx.stroke();

        console.log("" + xl + " " + xh + " " + yl + " " + yh);
    }

    findBB();

    $("#goBut").click(function () {
        findarea($("#nPts").val());
    });
  </script>
</body>
</html>