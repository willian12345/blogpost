# 响应 Pointer 交互事件

上一章我们分析了 sprite 的渲染，那么接下来得看看交互上最重要的交互事件系统了

为 sprite 添加一个 pointerdown 事件，即点击事件，移动设备上就是 touch 事件， desktop 设备上即 click 事件

还是用一个最简单的 demo 演示 example/sprite-pointerdown.html

```
const app = new PIXI.Application({ width: 800, height: 600 });  
document.body.appendChild(app.view);  

const sprite = PIXI.Sprite.from('logo.png');  

sprite.on('pointerdown', ()=> {
  console.log('clicked')
})

app.stage.addChild(sprite);
```

试着用鼠标点击 sprite ，会发现控制台并未输出期望的 'clicked'

奇奇怪怪，看下官网的例子，需要为 sprite 添加  `sprite.eventMode = 'static';`;

再运行，就可以看到控制台正常输出 'clicked' 了


## 显示对象没有自己的事件

Canvas 或者说 webgl 本身不像 DOM 那样每个元素都有添加交互事件的系统，需要自定义实现

首先，可交互的元素都应该是 DisplayObject 及继承自它的子类元素

`/packages/display/src/DisplayObject.ts` 第 210 行

```
export abstract class DisplayObject extends utils.EventEmitter<DisplayObjectEvents>
```

说明，DisplayObject 继承了 EventEmitter 类，因此就有了自定义的事件系统，所有对应的 API

> eventemitter3:   https://github.com/primus/eventemitter3

eventemitter3 的 REAMDME 过于简单

得看它的 测试用例  https://github.com/primus/eventemitter3/blob/master/test/test.js

可以发现 监听事件可以用 on, 触发事件可以用 emit 

所以 PixiJS 中的 DisplayObject 类实例对象就可以用 on  监听事件，用 emit 触发事件，即**有了自定义事件的能力**

当显示对象有了自定义事件能力后，需要一个事件管理系统来管理显示对象的事件触发、监听、移除

来看看 EventSystem 类

`/packages/events/src/EventSystem.ts` 204 -238 行 

```
constructor(renderer: IRenderer)
  {
    this.renderer = renderer;
    this.rootBoundary = new EventBoundary(null);
    EventsTicker.init(this);

    this.autoPreventDefault = true;
    this.eventsAdded = false;

    this.rootPointerEvent = new FederatedPointerEvent(null);
    this.rootWheelEvent = new FederatedWheelEvent(null);

    this.cursorStyles = {
        default: 'inherit',
        pointer: 'pointer',
    };

    this.features = new Proxy({ ...EventSystem.defaultEventFeatures }, {
        set: (target, key, value) =>
        {
            if (key === 'globalMove')
            {
                this.rootBoundary.enableGlobalMoveEvents = value;
            }
            target[key as keyof EventSystemFeatures] = value;

            return true;
        }
    });
    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerUp = this.onPointerUp.bind(this);
    this.onPointerOverOut = this.onPointerOverOut.bind(this);
    this.onWheel = this.onWheel.bind(this);
  }
```

> EventSystem.ts 的最后一行 extensions.add(EventSystem); 会将它以扩展插件的方式集成到 pixiJS 内

可以看到构造函数内很简单，

1. 传入了渲染器实例

2. rootBoudary 根“边界” 这个对象很重要，后面会具体介绍

3. 单独创建一个 ticker 用于管理事件，确保运行状态下显示对象的碰撞检测事件

4. 实例化了两个事件对象，用于触发时传递，事件对象内的数据结构

5. onPointerDown/onPointerMove/onPointerUp/onPointerOverOut/onWheel 等绑定到当前 this 上

当EventSystem 加入PixiJS 管理后，会被触发 'init' 这个 Runner ， 可理解这个 init 生命周期函数被触发

在 EventSystem.ts 第 245 - 254 行：

```
init(options: EventSystemOptions): void
{
    const { view, resolution } = this.renderer;

    this.setTargetElement(view as HTMLCanvasElement);
    this.resolution = resolution;
    EventSystem._defaultEventMode = options.eventMode ?? 'auto';
    Object.assign(this.features, options.eventFeatures ?? {});
    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
}
```

可以看到，这个根目标元素就是 渲染器对应的 view， 可以认为这个 view 就是 canvas 本身，它是可以响应浏览器的DOM 事件的, 当然包括，鼠标的点击，移动 等。


setTargetElement 函数 最终会调到 addEvents() 


在 EventSystem.ts 第 483 - 546 行：
```
private addEvents(): void
    {
      ... 省略部分源码
        if (this.supportsPointerEvents)
        {
            globalThis.document.addEventListener('pointermove', this.onPointerMove, true);
            this.domElement.addEventListener('pointerdown', this.onPointerDown, true);
            ... 省略部分源码
            globalThis.addEventListener('pointerup', this.onPointerUp, true);
        }
        else
        {
            globalThis.document.addEventListener('mousemove', this.onPointerMove, true);
            this.domElement.addEventListener('mousedown', this.onPointerDown, true);
            ... 省略部分源码

            if (this.supportsTouchEvents)
            {
                this.domElement.addEventListener('touchstart', this.onPointerDown, true);
               ... 省略部分源码
            }
        }

        this.domElement.addEventListener('wheel', this.onWheel, {
            passive: true,
            capture: true,
        });

        this.eventsAdded = true;
    }
```

此函数是真正为根元素添加事件监听器的地方。

如果支持 pointer 事件则使用 pointer 事件，

如果不支持 pointer 事件则使用 mouse 事件。

如果支持 touch 事件则也要添加上 touch 事件

> 注意 move 相关的事件是添加在 document 元素上的

至此，当用户点击 canvas 元素时，就相关的回调函数就会执行，如注册的   this.onPointerDown、this.onPointerUp 等

触发的回调函数内会去触发 eventemitter3 的自定义事件。

还是以我们在 sprite-pointer.html 中的例子为例，我们注册了 sprite-pointer.html 中 sprite.on('pointerdown', function() {})，那么当用户点击 canvas 元素时，就会触发这个回调函数。


在 onPointerDown 

在 EventSystem.ts 第 343 - 377 行：

private onPointerDown(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void
{
    ... 省略部分源码
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered as DisplayObject;

    const events = this.normalizeToPointerData(nativeEvent);
    ... 省略部分源码

    for (let i = 0, j = events.length; i < j; i++)
    {
        const nativeEvent = events[i];
        const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent);

        this.rootBoundary.mapEvent(federatedEvent);
    }

    ... 省略部分
}

1. 先指定当前 rootBoundary.rootTarget = this.renderer.lastObjectRendered 即响应事件的目标对象"为渲染器最上层的一个显示对象"

2. 适配浏览器原生事件 nativeEvent 后，调用 this.rootBoundary.mapEvent(federatedEvent)， federatedEvent 即标准化为 PixiJS 自定义事件


##  事件边界 EventBoundary

要准确的响应用户点击的操作，必须先确定用户点击的范围在哪里，然后将范围内的 DisplayObject 显示元素触发对应的点击事件

`/packages/events/src/EventBoundary.ts`

EventBoundary 构造函数 149 - 172 行 ：

```
constructor(rootTarget?: DisplayObject)
  {
      this.rootTarget = rootTarget;

      this.hitPruneFn = this.hitPruneFn.bind(this);
      this.hitTestFn = this.hitTestFn.bind(this);
      this.mapPointerDown = this.mapPointerDown.bind(this);
      this.mapPointerMove = this.mapPointerMove.bind(this);
      this.mapPointerOut = this.mapPointerOut.bind(this);
      this.mapPointerOver = this.mapPointerOver.bind(this);
      this.mapPointerUp = this.mapPointerUp.bind(this);
      this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
      this.mapWheel = this.mapWheel.bind(this);

      this.mappingTable = {};
      this.addEventMapping('pointerdown', this.mapPointerDown);
      this.addEventMapping('pointermove', this.mapPointerMove);
      this.addEventMapping('pointerout', this.mapPointerOut);
      this.addEventMapping('pointerleave', this.mapPointerOut);
      this.addEventMapping('pointerover', this.mapPointerOver);
      this.addEventMapping('pointerup', this.mapPointerUp);
      this.addEventMapping('pointerupoutside', this.mapPointerUpOutside);
      this.addEventMapping('wheel', this.mapWheel);
  }
```

构造函数内表明实例化后， 由 addEventMapping  方法 将pointerdown，pointermove， pointerout .... 等  8 类事件的回调映射函数保存在了 `mappingTable` 对象内

后续使用过程中用户添加到显示对象上的交互事件，都会被存储到对应的这 8 类事件列表中















