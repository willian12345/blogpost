使用 canvasRenderer 渲染

上一章分析了一下 Sprite 在默认 webgl  渲染上的渲染，这章让我们把目光聚集到 canvasRenderer 上


## 先写一个 canvas 渲染图片的 demo

要使用 canvas 作为渲染器，我们需要引用 pixi-legacy.js


见 `examples/sprite-canvas.html`


```
<script src="/bundles/pixi.js-legacy/dist/pixi-legacy.js"></script>
<script type="text/javascript">
const app = new PIXI.Application({ width: 800, height: 600 , forceCanvas: true});  
document.body.appendChild(app.view);  

const rectangle = PIXI.Sprite.from('logo.png');  
rectangle.x = 100;  
rectangle.y = 100;  
rectangle.anchor.set(0.5);  
rectangle.rotation = Math.PI / 4;  
app.stage.addChild(rectangle);  
</script>
```
同样创建一个简单的加载显示 logo 的 demo

运行它应该可以看到在第一章 simple.html 中一模一样的一张 logo 图被渲染在了网页上，如果运行不起来，请参考第一章中介绍的运行环境

在 Application.ts 的 constructor 函数内，即 78 行添加 `console.log(this.renderer);` 输出当前的渲染器看看

```
constructor(options?: Partial<IApplicationOptions>)
    {
        // The default options
        options = Object.assign({
            forceCanvas: false,
        }, options);

        this.renderer = autoDetectRenderer<VIEW>(options);
        console.log(this.renderer);
        // install plugins here
        Application._plugins.forEach((plugin) =>
        {
            plugin.init.call(this, options);
        });
    }
```

![image](./3-1.png)

图 3-1 

> 图 3-1  中可以发现输出了一个  _CanvasRenderer2 的而不是 CanvasRenderer 实例，是因为其实在 demo 中加载的 pixi.js 是经过 rollup 编译后的。


## Sprite 类

Sprite 是被 webgl 渲染器和 canvas 渲染器共用的

**注意** Sprite.ts 类本身并不做渲染，它只是用于一个 `Sprite` 类，保存了基本信息

在此处最终渲染到 canvas 上用的是 `CanvasSpriteRenderer` 渲染类

我们在直接使用 html 的 canvas 绘制图像时，是直接调用 context.draw 方法，并传递一个“图像源”

但在 pixi.js 内，这个图像源并不是直接的图像或canvas，而是先封装成了一个 texture 即xwgj对象，统一管理

找到  /packages/CanvasSpriteRenderer.ts 的第  37 - 40 行

```
static extension: ExtensionMetadata = {
    name: 'sprite',
    type: ExtensionType.CanvasRendererPlugin,
};
```

可以看到 CanvasSpriteRenderer 是一个渲染器的插件，当需要渲染一个 sprite 的时候调用的是此插件


最终被调用的 sprite  渲染方法, 即绘制图片或路径等到 canvas 上

```
render(sprite: Sprite): void
{
    const texture = sprite._texture;
    const renderer = this.renderer;
    const context = renderer.canvasContext.activeContext;
    const activeResolution = renderer.canvasContext.activeResolution;

    if (!texture.valid)
    {
        return;
    }

    const sourceWidth = texture._frame.width;
    const sourceHeight = texture._frame.height;

    let destWidth = texture._frame.width;
    let destHeight = texture._frame.height;

    if (texture.trim)
    {
        destWidth = texture.trim.width;
        destHeight = texture.trim.height;
    }

    let wt = sprite.transform.worldTransform;
    let dx = 0;
    let dy = 0;

    const source = texture.baseTexture.getDrawableSource();

    if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.valid || !source)
    {
        return;
    }

    renderer.canvasContext.setBlendMode(sprite.blendMode, true);

    context.globalAlpha = sprite.worldAlpha;

    // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture
    const smoothingEnabled = texture.baseTexture.scaleMode === SCALE_MODES.LINEAR;
    const smoothProperty = renderer.canvasContext.smoothProperty;

    if (smoothProperty
        && context[smoothProperty] !== smoothingEnabled)
    {
        context[smoothProperty] = smoothingEnabled;
    }

    if (texture.trim)
    {
        dx = (texture.trim.width / 2) + texture.trim.x - (sprite.anchor.x * texture.orig.width);
        dy = (texture.trim.height / 2) + texture.trim.y - (sprite.anchor.y * texture.orig.height);
    }
    else
    {
        dx = (0.5 - sprite.anchor.x) * texture.orig.width;
        dy = (0.5 - sprite.anchor.y) * texture.orig.height;
    }

    if (texture.rotate)
    {
        wt.copyTo(canvasRenderWorldTransform);
        wt = canvasRenderWorldTransform;
        groupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);
        // the anchor has already been applied above, so lets set it to zero
        dx = 0;
        dy = 0;
    }

    dx -= destWidth / 2;
    dy -= destHeight / 2;

    renderer.canvasContext.setContextTransform(wt, sprite.roundPixels, 1);
    // Allow for pixel rounding
    if (sprite.roundPixels)
    {
        dx = dx | 0;
        dy = dy | 0;
    }

    const resolution = texture.baseTexture.resolution;

    const outerBlend = renderer.canvasContext._outerBlend;

    if (outerBlend)
    {
        context.save();
        context.beginPath();
        context.rect(
            dx * activeResolution,
            dy * activeResolution,
            destWidth * activeResolution,
            destHeight * activeResolution
        );
        context.clip();
    }

    if (sprite.tint !== 0xFFFFFF)
    {
        if (sprite._cachedTint !== sprite.tintValue || sprite._tintedCanvas.tintId !== sprite._texture._updateID)
        {
            sprite._cachedTint = sprite.tintValue;

            // TODO clean up caching - how to clean up the caches?
            sprite._tintedCanvas = canvasUtils.getTintedCanvas(sprite, sprite.tintValue);
        }

        context.drawImage(
            sprite._tintedCanvas,
            0,
            0,
            Math.floor(sourceWidth * resolution),
            Math.floor(sourceHeight * resolution),
            Math.floor(dx * activeResolution),
            Math.floor(dy * activeResolution),
            Math.floor(destWidth * activeResolution),
            Math.floor(destHeight * activeResolution)
        );
    }
    else
    {
        context.drawImage(
            source,
            texture._frame.x * resolution,
            texture._frame.y * resolution,
            Math.floor(sourceWidth * resolution),
            Math.floor(sourceHeight * resolution),
            Math.floor(dx * activeResolution),
            Math.floor(dy * activeResolution),
            Math.floor(destWidth * activeResolution),
            Math.floor(destHeight * activeResolution)
        );
    }

    if (outerBlend)
    {
        context.restore();
    }
    // just in case, leaking outer blend here will be catastrophic!
    renderer.canvasContext.setBlendMode(BLEND_MODES.NORMAL);
}
```

我想 sprite  render 方法估计是在使用 pixi 时用的最多的方法

在此 render 方法内 打一个 debugger 后：

![image](./3-2.png)

图 3-2 

看一下方法的调用栈 从 图 3-2 中的红色向上箭头可以看到 _tick 函数一级一级往 render 方法内调用


## render 函数做了什么

render 方法大致做了以下几步：

1. 接受一个 sprite 对象实例，获取到这个 sprite 的当前 "激活的canvas2d上下文" activeContext
   
   当前激活的上下文不是固定的“根上下文” rootContext 而是可变的，因为可以并允许创建多个 canvas 的情况存在比如 “离屏渲染，用新的canvas缓存图片” 等

   在 `/packages/canvas-render/CanvasContextSystem.ts` 文件的第 79 行 `init()`  初始化方法内可以看到 `this.activeContext = this.rootContext;`  默认就是“根上下文”

2. 接下来是确定


mapCanvasBlendModesToPixi.ts


