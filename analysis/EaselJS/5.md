## Shadow 阴影

示例

```
myImage.shadow = new createjs.Shadow("#000000", 5, 5, 10);
```

Shadow.js 源码非常简单，它本身并没有 draw 方法

它只负责保存阴影的 color, offsetX, offsetY, blur 属性

在 DisplayObject 显示对象的 updateContext 被调用时，判断如果设有 shadow 属性，则调用  DisplayObject 的 _applyShadow 方法 

```
// DisplayObject.js 源码 1293-1299 行
p._applyShadow = function(ctx, shadow) {
  shadow = shadow || Shadow.identity;
  ctx.shadowColor = shadow.color;
  ctx.shadowOffsetX = shadow.offsetX;
  ctx.shadowOffsetY = shadow.offsetY;
  ctx.shadowBlur = shadow.blur;
};
```

可以看到，它仅仅是为上下文进行标准 shadow 赋值

## Filter

使用官方的示例 examples/Filters.html

```
// examples/Filters.html 片断
var colorMatrix = new createjs.ColorMatrix();
colorMatrix.adjustSaturation(-100);
colorMatrix.adjustContrast(50);
var blackAndWhiteFilter = new createjs.ColorMatrixFilter(colorMatrix);
bmp = bmp.clone();
// filters are only displayed when the display object is cached
// later, you can call updateCache() to update changes to your filters
bmp.filters = [blackAndWhiteFilter];
bmp.cache(0, 0, img.width, img.height);
stage.addChild(bmp);
```

如何使用 Filter ：

1. 在显示对象的 filters 属性内添加一个继承自 Filter 类实例即可

2. 保证应用 Filter 的显示对象需要调用 cache 缓存

3. 想更新缓存就调用显示对象的 updateCache() 方法

Filter 相关的源码文件都在 src/easeljs/filters/* 文件夹下

Filter 类文件 src/easeljs/filters/Filter.js 

Filter.js  类源码代码非常少

最主要的实例方法是 `applyFilter`

```
// Filter.js 源码 172-185 行
p.applyFilter = function(ctx, x, y, width, height, targetCtx) {
  // this is the default behaviour because most filters access pixel data. It is overridden when not needed.
  targetCtx = targetCtx || ctx;
  try {
    var imageData = ctx.getImageData(x, y, width, height);
  } catch (e) {
    return false;
  }
  if (this._applyFilter(imageData)) {
    targetCtx.putImageData(imageData, x, y);
    return true;
  }
  return false;
};
```

从方法名就可以知道这就是“应用滤镜” 

从源码中这里可以看到大概步骤就3步

1. 获取像素信息 `var imageData = ctx.getImageData(x, y, width, height);`

2. 调用 `_applyFilter` 传入像素信息 imageData，方法 _applyFilter 由子类自身去实现，也就是子类各自实现具体的滤镜效果

3. 应用滤镜 `targetCtx.putImageData(imageData, x, y);` 将变更后的像素信息重新写回 canvas 内

怪不得不调用 cache 进行缓存的话，filters 不让用，这像素级的操作，不缓存确实顶不住


## cache

当 DisplayObject 实例的 draw 方法被调用时

显示对象调用缓存方法，实际上是创建了一个 BitmaCache 实例，保存在 bitmapCache 属性内



```
p.cache = function(x, y, width, height, scale, options) {
  if (!this.bitmapCache){
    this.bitmapCache = new createjs.BitmapCache();
  } else {
    this.bitmapCache._autoGenerated = false;
  }
  this.bitmapCache.define(this, x, y, width, height, scale, options);
};
```

cache 调用 bitmapCache 的 define 方法定义此缓存的属性

define 方法调用 




----------


```
// DisplayObject.js 源码 772-778 行
p.draw = function(ctx, ignoreCache) {
  var cache = this.bitmapCache;
  if (cache && !ignoreCache) {
    return cache.draw(ctx);
  }
  return false;
};
```